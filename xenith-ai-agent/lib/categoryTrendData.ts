// new file

export interface CategoryTrendPoint {
  month: string
  [category: string]: string | number
}

// Simple deterministic pseudo-random number generator using mulberry32
function mulberry32(seed: number) {
  return function () {
    let t = (seed += 0x6d2b79f5)
    t = Math.imul(t ^ (t >>> 15), t | 1)
    t ^= t + Math.imul(t ^ (t >>> 7), t | 61)
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296
  }
}

/**
 * Generate monthly trend data for each category.
 * The last point (most recent month) equals the provided negativeCount.
 * Previous points are generated by applying a small linear trend (±10%)
 * and superimposing random noise within ±30% of the end value.
 * @param categories Array of category objects that include `category` and `negativeCount` fields
 * @param monthsCount Number of months to generate, defaults to 12
 * @param seed Fixed seed for deterministic randomness, defaults to 42
 */
export function generateCategoryTrendData(
  categories: { category: string; negativeCount: number }[],
  monthsCount: number = 12,
  seed: number = 42
): CategoryTrendPoint[] {
  const rand = mulberry32(seed)

  // Build list of month labels from oldest to newest
  const now = new Date()
  const monthLabels: string[] = []
  for (let i = monthsCount - 1; i >= 0; i--) {
    const d = new Date(now.getFullYear(), now.getMonth() - i, 1)
    const monthShort = d.toLocaleString('default', { month: 'short' })
    monthLabels.push(monthShort)
  }

  // Change the most recent label to "Now"
  if (monthLabels.length > 0) {
    monthLabels[monthLabels.length - 1] = "Now"
  }

  // Prepare slope per category (±10%)
  const slopes: Record<string, number> = {}
  categories.forEach((c) => {
    const finalVal = c.negativeCount
    const totalChange = (rand() * 0.8 - 0.4) * finalVal // ±40%
    slopes[c.category] = totalChange / (monthsCount - 1)
  })

  // Generate data points for each month
  const data: CategoryTrendPoint[] = monthLabels.map((label, idx) => {
    const point: CategoryTrendPoint = { month: label }
    categories.forEach((c) => {
      const finalVal = c.negativeCount
      const slope = slopes[c.category]
      const monthsFromEnd = monthsCount - 1 - idx
      let value: number
      if (monthsFromEnd === 0) {
        // Ensure final month matches provided count exactly
        value = finalVal
      } else {
        const baseline = finalVal - slope * monthsFromEnd
        const noise = (rand() * 0.6 - 0.3) * finalVal // ±30%
        value = Math.max(0, Math.round(baseline + noise))
      }
      point[c.category] = value
    })
    return point
  })

  return data
}